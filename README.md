# os

启动bochs的命令：``./bin/bochs -f bochsrc.disk``

编译二进制文件：``nasm -I include/ -o loader.bin loader.S``

将文件写到磁盘里：``dd if=./loader.bin of=/home/cdh/os/bochs/hd60M.img bs=512 count=1 seek=2 conv=notrunc``

* if：要烧写的文件
* of：虚拟磁盘的文件
* bs：512
* count：写的磁盘数量
* seek：定位的磁盘位置



## 加载mbr

```cmd
nasm -I include/ -o ../build/mbr mbr.S
dd if=../build/mbr of=/home/cdh/os/bochs/hd60M.img bs=512 count=1 conv=notrunc
```



## 加载loader

```cmd
nasm -I include/ -o ../build/loader loader.S
dd if=../build/loader of=/home/cdh/os/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc
```



## 启用分页机制

1. 准备好页目录表及页表
2. 将页表地址写入控制寄存器 cr3
3. 寄存器 cr0 的 PG 位置 1



```cmd
ld kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin 
```

* -Ttext 指定起始虚拟地址为 0xc0001500
* -e ADDRESS, --entry ADDRESS Set start address  ，用来指定程序的起始地址，用来指定程序从哪里开始执行



## elf文件

| ELF 目标文件类型                   | 描 述                                                        |
| ---------------------------------- | ------------------------------------------------------------ |
| 待重定位文件（relocatable file）   | 待重定位文件就是常说的目标文件，属于源文件编译后但未完成链接的半成品，它被用于与<br/>其他目标文件合并链接，以构建出二进制可执行文件或动态链接库。为什么称其为“待重定<br/>位”文件呢？原因是在该目标文件中，如果引用了其他外部文件（其他目标文件或库文件）<br/>中定义的符号（变量或者函数统称为符号），在编译阶段只能先标识出一个符号名，该符号具<br/>体的地址还不能确定，因为不知道该符号是在哪个外部文件中，而该外部文件需要被重定位<br/>后才能确定文件内的符号地址，这些重定位的工作是需要在连接的过程中完成的 |
| 共享目标文件（shared object file） | 这就是我们常说的动态链接库。在可执行文件被加载的过程中被动态链接，成为程序代码的<br/>一部分 |
| 可执行文件（executable file ）     | 经过编译链接后的、可以直接运行的程序文件                     |

![image-20241008064836535](/home/cdh/os/project/README.assets/image-20241008064836535.png)

elf使用程序头表（program header table）和节头表（section header table）

程序头表：存储多个程序头program header，也就是程序的段

节头表：存储多个节头section header，也就是节

ELF header，它位于文件最开始的部分，并具有固定大小，用来描述程序头表和节头表的大小及位置信息



## 中断

就是设置好8259A，开启对应的中断，后面加载号idt寄存器，将对应的服务程序地址做好，中断来后在其中查到对应的地址跳转进去，跳进去的是对应的汇编中断服务程序，在其中进行环境的保护，在调用对应的c语言中断服务程序，调用结束，返回并恢复环境



## makefile

伪目标使用   .PHONY:伪目标名  定义

自定义变量：变量名=值（字符串），多个值之间用空格分开。make 程序在处理时会用空格将值打散，
然后遍历每一个值。另外，值仅支持字符串类型，即使是数字也被当作字符串来处理。 变量引用的格式：$(变量名)。

隐含规则：对于一些使用频率非常高的规则，make 把它们当成是默认的，不需要显式地写
出来，当用户未在 makefile 中显式定义规则时，将默认使用隐含规则进行推导。

自动变量

* $@，表示规则中的目标文件名集合，如果存在多个目标文件，$@则表示其中每一个文件名记，’@’很像是 at，aim at，表示瞄准目标。
* $<，表示规则中依赖文件中的第 1 个文件。助记，‘<’很像是集合的最左边，也就是第 1 个。
* $^，表示规则中所有依赖文件的集合，如果集合中有重复的文件，$^会自动去重。助记，’^’很像从上往下罩的动作，能罩住很大的范围，所以称为集合。
* $?，表示规则中，所有比目标文件 mtime 更新的依赖文件集合。助记，’?’表示疑问，make 最大的疑问就是依赖文件的 mtime 是否比目标文件的 mtime 要新。

模式规则：%用来匹配任意多个非空字符。比如%.o 代表所有以.o 为结尾的文件，make 会拿这个字符串模式去文件系统上查找文件，默认为当前路径下。 %通常用在规则中的目标文件中，以用来匹配所有目标文件，%也可以用在规则中的依赖文件中，因为目标文件才是要生成的文件，所以当%用在依赖文件中时，其所匹配的文件名要以目标文件为准。这个就是执果索因去匹配的，但是要是直接执行这个的话，会将所有符合的依赖文件都执行



## assert 断言

ASSERT 是用来辅助程序调试的，所以通常是用在开发阶段。把程序该有的条件状态传给它，让它帮咱们监督此条件，一旦条件不符合就会报错并将程序挂起。`` ASSERT (条件表达式)； ``括号中的条件表达式就是上面所说的条件状态。

在 C 语言中 ASSERT 是用宏来定义的，其原理是判断传给 ASSERT 的表达式是否成立，若表达式成立
则什么都不做，否则打印出错信息并停止执行

| 命令            | 标准输出 | 错误输出 |
| --------------- | -------- | -------- |
| >/dev/null 2>&1 | 丢弃     | 丢弃     |
| 2>&1 >/dev/null | 丢弃     | 屏幕     |

这个是输出重定向，是将dd命令的默认输出更改掉，让其定向到空洞文件
